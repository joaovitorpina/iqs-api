// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"endereco/ent/cep"
	"endereco/ent/cidade"
	"endereco/ent/endereco"
	"endereco/ent/estado"
	"endereco/ent/predicate"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCep      = "Cep"
	TypeCidade   = "Cidade"
	TypeEndereco = "Endereco"
	TypeEstado   = "Estado"
)

// CepMutation represents an operation that mutates the Cep nodes in the graph.
type CepMutation struct {
	config
	op               Op
	typ              string
	id               *int32
	logradouro       *string
	bairro           *string
	clearedFields    map[string]struct{}
	cidade           *int
	clearedcidade    bool
	enderecos        map[int]struct{}
	removedenderecos map[int]struct{}
	clearedenderecos bool
	done             bool
	oldValue         func(context.Context) (*Cep, error)
	predicates       []predicate.Cep
}

var _ ent.Mutation = (*CepMutation)(nil)

// cepOption allows management of the mutation configuration using functional options.
type cepOption func(*CepMutation)

// newCepMutation creates new mutation for the Cep entity.
func newCepMutation(c config, op Op, opts ...cepOption) *CepMutation {
	m := &CepMutation{
		config:        c,
		op:            op,
		typ:           TypeCep,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCepID sets the ID field of the mutation.
func withCepID(id int32) cepOption {
	return func(m *CepMutation) {
		var (
			err   error
			once  sync.Once
			value *Cep
		)
		m.oldValue = func(ctx context.Context) (*Cep, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cep.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCep sets the old Cep of the mutation.
func withCep(node *Cep) cepOption {
	return func(m *CepMutation) {
		m.oldValue = func(context.Context) (*Cep, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CepMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CepMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Cep entities.
func (m *CepMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CepMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CepMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cep.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLogradouro sets the "logradouro" field.
func (m *CepMutation) SetLogradouro(s string) {
	m.logradouro = &s
}

// Logradouro returns the value of the "logradouro" field in the mutation.
func (m *CepMutation) Logradouro() (r string, exists bool) {
	v := m.logradouro
	if v == nil {
		return
	}
	return *v, true
}

// OldLogradouro returns the old "logradouro" field's value of the Cep entity.
// If the Cep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CepMutation) OldLogradouro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogradouro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogradouro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogradouro: %w", err)
	}
	return oldValue.Logradouro, nil
}

// ResetLogradouro resets all changes to the "logradouro" field.
func (m *CepMutation) ResetLogradouro() {
	m.logradouro = nil
}

// SetBairro sets the "bairro" field.
func (m *CepMutation) SetBairro(s string) {
	m.bairro = &s
}

// Bairro returns the value of the "bairro" field in the mutation.
func (m *CepMutation) Bairro() (r string, exists bool) {
	v := m.bairro
	if v == nil {
		return
	}
	return *v, true
}

// OldBairro returns the old "bairro" field's value of the Cep entity.
// If the Cep object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CepMutation) OldBairro(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBairro is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBairro requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBairro: %w", err)
	}
	return oldValue.Bairro, nil
}

// ResetBairro resets all changes to the "bairro" field.
func (m *CepMutation) ResetBairro() {
	m.bairro = nil
}

// SetCidadeID sets the "cidade" edge to the Cidade entity by id.
func (m *CepMutation) SetCidadeID(id int) {
	m.cidade = &id
}

// ClearCidade clears the "cidade" edge to the Cidade entity.
func (m *CepMutation) ClearCidade() {
	m.clearedcidade = true
}

// CidadeCleared reports if the "cidade" edge to the Cidade entity was cleared.
func (m *CepMutation) CidadeCleared() bool {
	return m.clearedcidade
}

// CidadeID returns the "cidade" edge ID in the mutation.
func (m *CepMutation) CidadeID() (id int, exists bool) {
	if m.cidade != nil {
		return *m.cidade, true
	}
	return
}

// CidadeIDs returns the "cidade" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CidadeID instead. It exists only for internal usage by the builders.
func (m *CepMutation) CidadeIDs() (ids []int) {
	if id := m.cidade; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCidade resets all changes to the "cidade" edge.
func (m *CepMutation) ResetCidade() {
	m.cidade = nil
	m.clearedcidade = false
}

// AddEnderecoIDs adds the "enderecos" edge to the Endereco entity by ids.
func (m *CepMutation) AddEnderecoIDs(ids ...int) {
	if m.enderecos == nil {
		m.enderecos = make(map[int]struct{})
	}
	for i := range ids {
		m.enderecos[ids[i]] = struct{}{}
	}
}

// ClearEnderecos clears the "enderecos" edge to the Endereco entity.
func (m *CepMutation) ClearEnderecos() {
	m.clearedenderecos = true
}

// EnderecosCleared reports if the "enderecos" edge to the Endereco entity was cleared.
func (m *CepMutation) EnderecosCleared() bool {
	return m.clearedenderecos
}

// RemoveEnderecoIDs removes the "enderecos" edge to the Endereco entity by IDs.
func (m *CepMutation) RemoveEnderecoIDs(ids ...int) {
	if m.removedenderecos == nil {
		m.removedenderecos = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.enderecos, ids[i])
		m.removedenderecos[ids[i]] = struct{}{}
	}
}

// RemovedEnderecos returns the removed IDs of the "enderecos" edge to the Endereco entity.
func (m *CepMutation) RemovedEnderecosIDs() (ids []int) {
	for id := range m.removedenderecos {
		ids = append(ids, id)
	}
	return
}

// EnderecosIDs returns the "enderecos" edge IDs in the mutation.
func (m *CepMutation) EnderecosIDs() (ids []int) {
	for id := range m.enderecos {
		ids = append(ids, id)
	}
	return
}

// ResetEnderecos resets all changes to the "enderecos" edge.
func (m *CepMutation) ResetEnderecos() {
	m.enderecos = nil
	m.clearedenderecos = false
	m.removedenderecos = nil
}

// Where appends a list predicates to the CepMutation builder.
func (m *CepMutation) Where(ps ...predicate.Cep) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CepMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cep).
func (m *CepMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CepMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.logradouro != nil {
		fields = append(fields, cep.FieldLogradouro)
	}
	if m.bairro != nil {
		fields = append(fields, cep.FieldBairro)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CepMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cep.FieldLogradouro:
		return m.Logradouro()
	case cep.FieldBairro:
		return m.Bairro()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CepMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cep.FieldLogradouro:
		return m.OldLogradouro(ctx)
	case cep.FieldBairro:
		return m.OldBairro(ctx)
	}
	return nil, fmt.Errorf("unknown Cep field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CepMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cep.FieldLogradouro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogradouro(v)
		return nil
	case cep.FieldBairro:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBairro(v)
		return nil
	}
	return fmt.Errorf("unknown Cep field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CepMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CepMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CepMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cep numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CepMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CepMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CepMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cep nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CepMutation) ResetField(name string) error {
	switch name {
	case cep.FieldLogradouro:
		m.ResetLogradouro()
		return nil
	case cep.FieldBairro:
		m.ResetBairro()
		return nil
	}
	return fmt.Errorf("unknown Cep field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CepMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cidade != nil {
		edges = append(edges, cep.EdgeCidade)
	}
	if m.enderecos != nil {
		edges = append(edges, cep.EdgeEnderecos)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CepMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cep.EdgeCidade:
		if id := m.cidade; id != nil {
			return []ent.Value{*id}
		}
	case cep.EdgeEnderecos:
		ids := make([]ent.Value, 0, len(m.enderecos))
		for id := range m.enderecos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CepMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedenderecos != nil {
		edges = append(edges, cep.EdgeEnderecos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CepMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cep.EdgeEnderecos:
		ids := make([]ent.Value, 0, len(m.removedenderecos))
		for id := range m.removedenderecos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CepMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcidade {
		edges = append(edges, cep.EdgeCidade)
	}
	if m.clearedenderecos {
		edges = append(edges, cep.EdgeEnderecos)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CepMutation) EdgeCleared(name string) bool {
	switch name {
	case cep.EdgeCidade:
		return m.clearedcidade
	case cep.EdgeEnderecos:
		return m.clearedenderecos
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CepMutation) ClearEdge(name string) error {
	switch name {
	case cep.EdgeCidade:
		m.ClearCidade()
		return nil
	}
	return fmt.Errorf("unknown Cep unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CepMutation) ResetEdge(name string) error {
	switch name {
	case cep.EdgeCidade:
		m.ResetCidade()
		return nil
	case cep.EdgeEnderecos:
		m.ResetEnderecos()
		return nil
	}
	return fmt.Errorf("unknown Cep edge %s", name)
}

// CidadeMutation represents an operation that mutates the Cidade nodes in the graph.
type CidadeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	nome          *string
	clearedFields map[string]struct{}
	estado        *int
	clearedestado bool
	ceps          map[int32]struct{}
	removedceps   map[int32]struct{}
	clearedceps   bool
	done          bool
	oldValue      func(context.Context) (*Cidade, error)
	predicates    []predicate.Cidade
}

var _ ent.Mutation = (*CidadeMutation)(nil)

// cidadeOption allows management of the mutation configuration using functional options.
type cidadeOption func(*CidadeMutation)

// newCidadeMutation creates new mutation for the Cidade entity.
func newCidadeMutation(c config, op Op, opts ...cidadeOption) *CidadeMutation {
	m := &CidadeMutation{
		config:        c,
		op:            op,
		typ:           TypeCidade,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCidadeID sets the ID field of the mutation.
func withCidadeID(id int) cidadeOption {
	return func(m *CidadeMutation) {
		var (
			err   error
			once  sync.Once
			value *Cidade
		)
		m.oldValue = func(ctx context.Context) (*Cidade, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cidade.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCidade sets the old Cidade of the mutation.
func withCidade(node *Cidade) cidadeOption {
	return func(m *CidadeMutation) {
		m.oldValue = func(context.Context) (*Cidade, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CidadeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CidadeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CidadeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CidadeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cidade.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNome sets the "nome" field.
func (m *CidadeMutation) SetNome(s string) {
	m.nome = &s
}

// Nome returns the value of the "nome" field in the mutation.
func (m *CidadeMutation) Nome() (r string, exists bool) {
	v := m.nome
	if v == nil {
		return
	}
	return *v, true
}

// OldNome returns the old "nome" field's value of the Cidade entity.
// If the Cidade object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CidadeMutation) OldNome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNome: %w", err)
	}
	return oldValue.Nome, nil
}

// ResetNome resets all changes to the "nome" field.
func (m *CidadeMutation) ResetNome() {
	m.nome = nil
}

// SetEstadoID sets the "estado" edge to the Estado entity by id.
func (m *CidadeMutation) SetEstadoID(id int) {
	m.estado = &id
}

// ClearEstado clears the "estado" edge to the Estado entity.
func (m *CidadeMutation) ClearEstado() {
	m.clearedestado = true
}

// EstadoCleared reports if the "estado" edge to the Estado entity was cleared.
func (m *CidadeMutation) EstadoCleared() bool {
	return m.clearedestado
}

// EstadoID returns the "estado" edge ID in the mutation.
func (m *CidadeMutation) EstadoID() (id int, exists bool) {
	if m.estado != nil {
		return *m.estado, true
	}
	return
}

// EstadoIDs returns the "estado" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstadoID instead. It exists only for internal usage by the builders.
func (m *CidadeMutation) EstadoIDs() (ids []int) {
	if id := m.estado; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstado resets all changes to the "estado" edge.
func (m *CidadeMutation) ResetEstado() {
	m.estado = nil
	m.clearedestado = false
}

// AddCepIDs adds the "ceps" edge to the Cep entity by ids.
func (m *CidadeMutation) AddCepIDs(ids ...int32) {
	if m.ceps == nil {
		m.ceps = make(map[int32]struct{})
	}
	for i := range ids {
		m.ceps[ids[i]] = struct{}{}
	}
}

// ClearCeps clears the "ceps" edge to the Cep entity.
func (m *CidadeMutation) ClearCeps() {
	m.clearedceps = true
}

// CepsCleared reports if the "ceps" edge to the Cep entity was cleared.
func (m *CidadeMutation) CepsCleared() bool {
	return m.clearedceps
}

// RemoveCepIDs removes the "ceps" edge to the Cep entity by IDs.
func (m *CidadeMutation) RemoveCepIDs(ids ...int32) {
	if m.removedceps == nil {
		m.removedceps = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.ceps, ids[i])
		m.removedceps[ids[i]] = struct{}{}
	}
}

// RemovedCeps returns the removed IDs of the "ceps" edge to the Cep entity.
func (m *CidadeMutation) RemovedCepsIDs() (ids []int32) {
	for id := range m.removedceps {
		ids = append(ids, id)
	}
	return
}

// CepsIDs returns the "ceps" edge IDs in the mutation.
func (m *CidadeMutation) CepsIDs() (ids []int32) {
	for id := range m.ceps {
		ids = append(ids, id)
	}
	return
}

// ResetCeps resets all changes to the "ceps" edge.
func (m *CidadeMutation) ResetCeps() {
	m.ceps = nil
	m.clearedceps = false
	m.removedceps = nil
}

// Where appends a list predicates to the CidadeMutation builder.
func (m *CidadeMutation) Where(ps ...predicate.Cidade) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CidadeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cidade).
func (m *CidadeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CidadeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.nome != nil {
		fields = append(fields, cidade.FieldNome)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CidadeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cidade.FieldNome:
		return m.Nome()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CidadeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cidade.FieldNome:
		return m.OldNome(ctx)
	}
	return nil, fmt.Errorf("unknown Cidade field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CidadeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cidade.FieldNome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNome(v)
		return nil
	}
	return fmt.Errorf("unknown Cidade field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CidadeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CidadeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CidadeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Cidade numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CidadeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CidadeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CidadeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Cidade nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CidadeMutation) ResetField(name string) error {
	switch name {
	case cidade.FieldNome:
		m.ResetNome()
		return nil
	}
	return fmt.Errorf("unknown Cidade field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CidadeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.estado != nil {
		edges = append(edges, cidade.EdgeEstado)
	}
	if m.ceps != nil {
		edges = append(edges, cidade.EdgeCeps)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CidadeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cidade.EdgeEstado:
		if id := m.estado; id != nil {
			return []ent.Value{*id}
		}
	case cidade.EdgeCeps:
		ids := make([]ent.Value, 0, len(m.ceps))
		for id := range m.ceps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CidadeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedceps != nil {
		edges = append(edges, cidade.EdgeCeps)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CidadeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cidade.EdgeCeps:
		ids := make([]ent.Value, 0, len(m.removedceps))
		for id := range m.removedceps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CidadeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedestado {
		edges = append(edges, cidade.EdgeEstado)
	}
	if m.clearedceps {
		edges = append(edges, cidade.EdgeCeps)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CidadeMutation) EdgeCleared(name string) bool {
	switch name {
	case cidade.EdgeEstado:
		return m.clearedestado
	case cidade.EdgeCeps:
		return m.clearedceps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CidadeMutation) ClearEdge(name string) error {
	switch name {
	case cidade.EdgeEstado:
		m.ClearEstado()
		return nil
	}
	return fmt.Errorf("unknown Cidade unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CidadeMutation) ResetEdge(name string) error {
	switch name {
	case cidade.EdgeEstado:
		m.ResetEstado()
		return nil
	case cidade.EdgeCeps:
		m.ResetCeps()
		return nil
	}
	return fmt.Errorf("unknown Cidade edge %s", name)
}

// EnderecoMutation represents an operation that mutates the Endereco nodes in the graph.
type EnderecoMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	numero        *string
	clearedFields map[string]struct{}
	cep           *int32
	clearedcep    bool
	done          bool
	oldValue      func(context.Context) (*Endereco, error)
	predicates    []predicate.Endereco
}

var _ ent.Mutation = (*EnderecoMutation)(nil)

// enderecoOption allows management of the mutation configuration using functional options.
type enderecoOption func(*EnderecoMutation)

// newEnderecoMutation creates new mutation for the Endereco entity.
func newEnderecoMutation(c config, op Op, opts ...enderecoOption) *EnderecoMutation {
	m := &EnderecoMutation{
		config:        c,
		op:            op,
		typ:           TypeEndereco,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnderecoID sets the ID field of the mutation.
func withEnderecoID(id int) enderecoOption {
	return func(m *EnderecoMutation) {
		var (
			err   error
			once  sync.Once
			value *Endereco
		)
		m.oldValue = func(ctx context.Context) (*Endereco, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Endereco.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEndereco sets the old Endereco of the mutation.
func withEndereco(node *Endereco) enderecoOption {
	return func(m *EnderecoMutation) {
		m.oldValue = func(context.Context) (*Endereco, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnderecoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnderecoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnderecoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnderecoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Endereco.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *EnderecoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EnderecoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Endereco entity.
// If the Endereco object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnderecoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EnderecoMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *EnderecoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *EnderecoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Endereco entity.
// If the Endereco object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnderecoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *EnderecoMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetNumero sets the "numero" field.
func (m *EnderecoMutation) SetNumero(s string) {
	m.numero = &s
}

// Numero returns the value of the "numero" field in the mutation.
func (m *EnderecoMutation) Numero() (r string, exists bool) {
	v := m.numero
	if v == nil {
		return
	}
	return *v, true
}

// OldNumero returns the old "numero" field's value of the Endereco entity.
// If the Endereco object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnderecoMutation) OldNumero(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumero is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumero requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumero: %w", err)
	}
	return oldValue.Numero, nil
}

// ResetNumero resets all changes to the "numero" field.
func (m *EnderecoMutation) ResetNumero() {
	m.numero = nil
}

// SetCepID sets the "cep" edge to the Cep entity by id.
func (m *EnderecoMutation) SetCepID(id int32) {
	m.cep = &id
}

// ClearCep clears the "cep" edge to the Cep entity.
func (m *EnderecoMutation) ClearCep() {
	m.clearedcep = true
}

// CepCleared reports if the "cep" edge to the Cep entity was cleared.
func (m *EnderecoMutation) CepCleared() bool {
	return m.clearedcep
}

// CepID returns the "cep" edge ID in the mutation.
func (m *EnderecoMutation) CepID() (id int32, exists bool) {
	if m.cep != nil {
		return *m.cep, true
	}
	return
}

// CepIDs returns the "cep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CepID instead. It exists only for internal usage by the builders.
func (m *EnderecoMutation) CepIDs() (ids []int32) {
	if id := m.cep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCep resets all changes to the "cep" edge.
func (m *EnderecoMutation) ResetCep() {
	m.cep = nil
	m.clearedcep = false
}

// Where appends a list predicates to the EnderecoMutation builder.
func (m *EnderecoMutation) Where(ps ...predicate.Endereco) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnderecoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Endereco).
func (m *EnderecoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnderecoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, endereco.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, endereco.FieldUpdateTime)
	}
	if m.numero != nil {
		fields = append(fields, endereco.FieldNumero)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnderecoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case endereco.FieldCreateTime:
		return m.CreateTime()
	case endereco.FieldUpdateTime:
		return m.UpdateTime()
	case endereco.FieldNumero:
		return m.Numero()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnderecoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case endereco.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case endereco.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case endereco.FieldNumero:
		return m.OldNumero(ctx)
	}
	return nil, fmt.Errorf("unknown Endereco field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnderecoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case endereco.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case endereco.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case endereco.FieldNumero:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumero(v)
		return nil
	}
	return fmt.Errorf("unknown Endereco field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnderecoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnderecoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnderecoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Endereco numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnderecoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnderecoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnderecoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Endereco nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnderecoMutation) ResetField(name string) error {
	switch name {
	case endereco.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case endereco.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case endereco.FieldNumero:
		m.ResetNumero()
		return nil
	}
	return fmt.Errorf("unknown Endereco field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnderecoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cep != nil {
		edges = append(edges, endereco.EdgeCep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnderecoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case endereco.EdgeCep:
		if id := m.cep; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnderecoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnderecoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnderecoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcep {
		edges = append(edges, endereco.EdgeCep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnderecoMutation) EdgeCleared(name string) bool {
	switch name {
	case endereco.EdgeCep:
		return m.clearedcep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnderecoMutation) ClearEdge(name string) error {
	switch name {
	case endereco.EdgeCep:
		m.ClearCep()
		return nil
	}
	return fmt.Errorf("unknown Endereco unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnderecoMutation) ResetEdge(name string) error {
	switch name {
	case endereco.EdgeCep:
		m.ResetCep()
		return nil
	}
	return fmt.Errorf("unknown Endereco edge %s", name)
}

// EstadoMutation represents an operation that mutates the Estado nodes in the graph.
type EstadoMutation struct {
	config
	op             Op
	typ            string
	id             *int
	nome           *string
	clearedFields  map[string]struct{}
	cidades        map[int]struct{}
	removedcidades map[int]struct{}
	clearedcidades bool
	done           bool
	oldValue       func(context.Context) (*Estado, error)
	predicates     []predicate.Estado
}

var _ ent.Mutation = (*EstadoMutation)(nil)

// estadoOption allows management of the mutation configuration using functional options.
type estadoOption func(*EstadoMutation)

// newEstadoMutation creates new mutation for the Estado entity.
func newEstadoMutation(c config, op Op, opts ...estadoOption) *EstadoMutation {
	m := &EstadoMutation{
		config:        c,
		op:            op,
		typ:           TypeEstado,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstadoID sets the ID field of the mutation.
func withEstadoID(id int) estadoOption {
	return func(m *EstadoMutation) {
		var (
			err   error
			once  sync.Once
			value *Estado
		)
		m.oldValue = func(ctx context.Context) (*Estado, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Estado.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstado sets the old Estado of the mutation.
func withEstado(node *Estado) estadoOption {
	return func(m *EstadoMutation) {
		m.oldValue = func(context.Context) (*Estado, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstadoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstadoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EstadoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EstadoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Estado.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNome sets the "nome" field.
func (m *EstadoMutation) SetNome(s string) {
	m.nome = &s
}

// Nome returns the value of the "nome" field in the mutation.
func (m *EstadoMutation) Nome() (r string, exists bool) {
	v := m.nome
	if v == nil {
		return
	}
	return *v, true
}

// OldNome returns the old "nome" field's value of the Estado entity.
// If the Estado object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstadoMutation) OldNome(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNome: %w", err)
	}
	return oldValue.Nome, nil
}

// ResetNome resets all changes to the "nome" field.
func (m *EstadoMutation) ResetNome() {
	m.nome = nil
}

// AddCidadeIDs adds the "cidades" edge to the Cidade entity by ids.
func (m *EstadoMutation) AddCidadeIDs(ids ...int) {
	if m.cidades == nil {
		m.cidades = make(map[int]struct{})
	}
	for i := range ids {
		m.cidades[ids[i]] = struct{}{}
	}
}

// ClearCidades clears the "cidades" edge to the Cidade entity.
func (m *EstadoMutation) ClearCidades() {
	m.clearedcidades = true
}

// CidadesCleared reports if the "cidades" edge to the Cidade entity was cleared.
func (m *EstadoMutation) CidadesCleared() bool {
	return m.clearedcidades
}

// RemoveCidadeIDs removes the "cidades" edge to the Cidade entity by IDs.
func (m *EstadoMutation) RemoveCidadeIDs(ids ...int) {
	if m.removedcidades == nil {
		m.removedcidades = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cidades, ids[i])
		m.removedcidades[ids[i]] = struct{}{}
	}
}

// RemovedCidades returns the removed IDs of the "cidades" edge to the Cidade entity.
func (m *EstadoMutation) RemovedCidadesIDs() (ids []int) {
	for id := range m.removedcidades {
		ids = append(ids, id)
	}
	return
}

// CidadesIDs returns the "cidades" edge IDs in the mutation.
func (m *EstadoMutation) CidadesIDs() (ids []int) {
	for id := range m.cidades {
		ids = append(ids, id)
	}
	return
}

// ResetCidades resets all changes to the "cidades" edge.
func (m *EstadoMutation) ResetCidades() {
	m.cidades = nil
	m.clearedcidades = false
	m.removedcidades = nil
}

// Where appends a list predicates to the EstadoMutation builder.
func (m *EstadoMutation) Where(ps ...predicate.Estado) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EstadoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Estado).
func (m *EstadoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EstadoMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.nome != nil {
		fields = append(fields, estado.FieldNome)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EstadoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estado.FieldNome:
		return m.Nome()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EstadoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estado.FieldNome:
		return m.OldNome(ctx)
	}
	return nil, fmt.Errorf("unknown Estado field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstadoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estado.FieldNome:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNome(v)
		return nil
	}
	return fmt.Errorf("unknown Estado field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EstadoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EstadoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstadoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Estado numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EstadoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EstadoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstadoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Estado nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EstadoMutation) ResetField(name string) error {
	switch name {
	case estado.FieldNome:
		m.ResetNome()
		return nil
	}
	return fmt.Errorf("unknown Estado field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EstadoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cidades != nil {
		edges = append(edges, estado.EdgeCidades)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EstadoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case estado.EdgeCidades:
		ids := make([]ent.Value, 0, len(m.cidades))
		for id := range m.cidades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EstadoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcidades != nil {
		edges = append(edges, estado.EdgeCidades)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EstadoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case estado.EdgeCidades:
		ids := make([]ent.Value, 0, len(m.removedcidades))
		for id := range m.removedcidades {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EstadoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcidades {
		edges = append(edges, estado.EdgeCidades)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EstadoMutation) EdgeCleared(name string) bool {
	switch name {
	case estado.EdgeCidades:
		return m.clearedcidades
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EstadoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Estado unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EstadoMutation) ResetEdge(name string) error {
	switch name {
	case estado.EdgeCidades:
		m.ResetCidades()
		return nil
	}
	return fmt.Errorf("unknown Estado edge %s", name)
}
